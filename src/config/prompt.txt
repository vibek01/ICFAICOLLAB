Project Overview
Project Name: Project Showcase
Stack:

Backend: Node.js, Express.js, MongoDB (Mongoose)
Authentication: JSON Web Tokens (JWT) with cookies, bcrypt for password hashing
Frontend: Plain HTML, CSS, and JavaScript (no templating engine like EJS)
File Uploads: Handled by Multer (files stored in a local /uploads directory)
Main Features:

User Authentication:

Users can sign up, log in, and log out.
Passwords are hashed using bcrypt before saving.
JWT tokens are generated on login and stored as HTTP-only cookies.
Role-based access control (users vs. admins) is implemented.
Project Management:

Users can upload projects with file attachments (images, videos, or code archives).
Projects include fields such as title, description, domain, and file URL.
A dedicated dashboard page displays projects that a user has uploaded.
Advertisement (Ad) Management:

Users can create ads that include a title, domain, and description.
Each ad is associated with the creator’s user ID.
Join Requests:
Ads store an array of joinRequests. Each join request object has a reference to a user and a status (pending, accepted, or declined).
Other users (applicants) can send join requests to ads (except to their own).
Ad owners can view received join requests and accept or decline them.
Applicants can view the join requests they sent and see the updated status.
Dashboard:

The user dashboard (user.html) displays:
User profile details.
The projects the user has uploaded.
“My Team Ads”: Ads created by the user, with a summary of join request statuses.
“Join Requests Received”: Detailed list (for ad owners) with Accept/Decline buttons.
“My Join Requests”: For applicants – ads to which they applied and the current status.
File Uploads:

The project upload functionality uses Multer with a custom storage engine.
Uploaded files are saved to /uploads.
The upload form in upload.html uses multipart/form-data and includes fields for domain, project title, description, and file upload (plus an optional demo video).
Folder Structure
pgsql
Copy
Edit
API - COPY/
├── node_modules/                  # (Dependencies installed by npm)
├── public/
│   ├── about.html
│   ├── all-user.html
│   ├── login.html
│   ├── signup.html
│   ├── upload.html
│   ├── settings.html
│   ├── profile.html
│   ├── user.html
│   ├── view-ads.html
│   └── view-project.html
│   └── view-projects.html
│   └── ads.html
│   └── landing.html
|   
├── config/
│   ├── db.js
│   └── prompt.txt
├── src/
│   ├── controllers/
│   │   ├── ad.controller.js
│   │   ├── auth.controller.js
│   │   ├── project.controller.js
│   │   └── user.controller.js
│   ├── middlewares/
│   │   ├── auth.middleware.js
│   │   └── error.middleware.js
│   ├── models/
│   │   ├── ad.model.js
│   │   ├── project.model.js
│   │   └── user.model.js
│   └── routes/
│       ├── ad.routes.js
│       ├── auth.routes.js
│       ├── index.js
│       ├── project.routes.js
│       └── user.routes.js
├── uploads/
├── .env
├── .gitignore
├── package-lock.json
├── package.json
└── server.js
Key Code Snippets
1. User Model (user.model.js)
js
Copy
Edit
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const UserSchema = new mongoose.Schema(
  {
    name: { type: String, required: true },
    email: { type: String, required: true, unique: true },
    password: { type: String, required: true },
    domain: { type: String },
    role: { type: String, enum: ['user', 'admin'], default: 'user' }
  },
  { timestamps: true }
);

// Hash password before saving
UserSchema.pre('save', async function(next) {
  if (!this.isModified('password')) return next();
  const salt = await bcrypt.genSalt(10);
  this.password = await bcrypt.hash(this.password, salt);
  next();
});

UserSchema.methods.matchPassword = async function(enteredPassword) {
  return await bcrypt.compare(enteredPassword, this.password);
};

module.exports = mongoose.model('User', UserSchema);
2. Ad Model (ad.model.js)
js
Copy
Edit
const mongoose = require('mongoose');

const JoinRequestSchema = new mongoose.Schema({
  user: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
  status: { type: String, enum: ['pending', 'accepted', 'declined'], default: 'pending' }
}, { _id: false });

const AdSchema = new mongoose.Schema(
  {
    userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
    domain: String,
    title: String,
    description: String,
    joinRequests: { type: [JoinRequestSchema], default: [] }
  },
  { timestamps: true }
);

module.exports = mongoose.model('Ad', AdSchema);
3. Project Model (project.model.js)
js
Copy
Edit
const mongoose = require('mongoose');

const ProjectSchema = new mongoose.Schema({
  userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
  title: String,
  description: String,
  domain: String,
  fileUrl: String  // URL to the uploaded file
}, { timestamps: true });

module.exports = mongoose.model('Project', ProjectSchema);
4. Ad Controller (ad.controller.js) – Join Requests & Related Endpoints
js
Copy
Edit
const mongoose = require('mongoose');
const Ad = require('../models/ad.model');

exports.createAd = async (req, res) => {
  try {
    const { domain, title, description } = req.body;
    const ad = new Ad({ domain, title, description, userId: req.user.id });
    await ad.save();
    res.status(201).json({ success: true, message: 'Ad created successfully', data: ad });
  } catch (err) {
    res.status(500).json({ success: false, error: err.message });
  }
};

exports.getAds = async (req, res) => {
  try {
    const ads = await Ad.find().sort({ createdAt: -1 }).populate('userId', 'name email');
    res.json({ success: true, data: ads });
  } catch (err) {
    res.status(500).json({ success: false, error: err.message });
  }
};

exports.getMyAds = async (req, res) => {
  try {
    const ads = await Ad.find({ userId: req.user.id })
      .sort({ createdAt: -1 })
      .populate('userId', 'name email')
      .populate('joinRequests.user', 'name email');
    res.json({ success: true, data: ads });
  } catch (err) {
    res.status(500).json({ success: false, error: err.message });
  }
};

exports.getMyJoinRequests = async (req, res) => {
  try {
    const currentUserId = new mongoose.Types.ObjectId(req.user.id);
    const ads = await Ad.find({ "joinRequests.user": { $in: [currentUserId] } })
      .populate('userId', 'name email')
      .populate('joinRequests.user', 'name email');
    const myJoinRequests = ads.map(ad => {
      const myRequests = ad.joinRequests.filter(jr => jr.user._id.toString() === req.user.id);
      return { adId: ad._id, title: ad.title, owner: ad.userId, joinRequests: myRequests };
    });
    res.json({ success: true, data: myJoinRequests });
  } catch (err) {
    res.status(500).json({ success: false, error: err.message });
  }
};

exports.sendJoinRequest = async (req, res) => {
  try {
    const adId = req.params.adId;
    const ad = await Ad.findById(adId);
    if (!ad) return res.status(404).json({ success: false, error: 'Ad not found' });
    if (ad.userId.toString() === req.user.id) return res.status(400).json({ success: false, error: 'You cannot send a join request to your own ad' });
    if (ad.joinRequests.some(jr => jr.user.toString() === req.user.id)) {
      return res.status(400).json({ success: false, error: 'Join request already sent' });
    }
    ad.joinRequests.push({ user: req.user.id, status: 'pending' });
    await ad.save();
    res.json({ success: true, message: 'Join request sent successfully' });
  } catch (err) {
    res.status(500).json({ success: false, error: err.message });
  }
};

exports.acceptJoinRequest = async (req, res) => {
  try {
    const { adId, requesterId } = req.params;
    const ad = await Ad.findById(adId);
    if (!ad) return res.status(404).json({ success: false, error: 'Ad not found' });
    if (ad.userId.toString() !== req.user.id) return res.status(403).json({ success: false, error: 'Not authorized' });
    const joinRequest = ad.joinRequests.find(jr => jr.user.toString() === requesterId);
    if (!joinRequest) return res.status(404).json({ success: false, error: 'Join request not found' });
    joinRequest.status = 'accepted';
    await ad.save();
    res.json({ success: true, message: 'Join request accepted' });
  } catch (err) {
    res.status(500).json({ success: false, error: err.message });
  }
};

exports.declineJoinRequest = async (req, res) => {
  try {
    const { adId, requesterId } = req.params;
    const ad = await Ad.findById(adId);
    if (!ad) return res.status(404).json({ success: false, error: 'Ad not found' });
    if (ad.userId.toString() !== req.user.id) return res.status(403).json({ success: false, error: 'Not authorized' });
    const joinRequest = ad.joinRequests.find(jr => jr.user.toString() === requesterId);
    if (!joinRequest) return res.status(404).json({ success: false, error: 'Join request not found' });
    joinRequest.status = 'declined';
    await ad.save();
    res.json({ success: true, message: 'Join request declined' });
  } catch (err) {
    res.status(500).json({ success: false, error: err.message });
  }
};

exports.getJoinRequestsForMyAds = async (req, res) => {
  try {
    const ads = await Ad.find({ userId: req.user.id })
      .populate('joinRequests.user', 'name email');
    const joinRequestsData = ads.map(ad => ({
      adId: ad._id,
      title: ad.title,
      joinRequests: ad.joinRequests || []
    }));
    res.json({ success: true, data: joinRequestsData });
  } catch (err) {
    res.status(500).json({ success: false, error: err.message });
  }
};
5. Folder Structure Recap
pgsql
Copy
Edit
Summary for the Chatbot
Project: Project Showcase
Stack: Node.js, Express.js, MongoDB (Mongoose), plain HTML/CSS/JS
Features:

User Authentication: Signup, login, logout with JWT and bcrypt.
Project Upload: Users can upload projects (with file attachments via Multer).
Ad Management:
Users can create ads (with fields: domain, title, description).
Ads store an array of joinRequests (each join request has a user reference and status: pending/accepted/declined).
Endpoints exist for sending join requests (by applicants), and for ad owners to view, accept, or decline join requests.
Dashboard: The user dashboard displays user details, projects, “My Team Ads” (ads the user created), “Join Requests Received” (for ad owners), and “My Join Requests” (for applicants).
Key Endpoints:

/api/users/me – Fetch current user data
/api/projects/my-projects – Fetch projects uploaded by the user
/api/ads/my-ads – Fetch ads created by the user
/api/ads/my-join-requests – Fetch join requests received (for ads the user created)
/api/ads/my-join-requests-applicant – Fetch join requests the user sent (for ads they applied to)
/api/ads/:adId/join – Send a join request
/api/ads/:adId/join/:requesterId/accept – Accept a join request
/api/ads/:adId/join/:requesterId/decline – Decline a join request
Folder Structure:
(Provide the structure as above)

Code Examples:
Include snippets for user.model.js, ad.model.js, project.model.js, and key controller functions (as provided above).

Note on Debugging:

Ensure that JWT middleware correctly populates req.user.id
In join requests, verify that the stored ObjectIds are correctly compared (using jr.user._id.toString() if necessary)
This detailed prompt with code and structure should help another chatbot understand the entire project.